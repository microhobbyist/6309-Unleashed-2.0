/* =========================================================
   REUSABLE WAIT-STATE GENERATOR TEMPLATE (ATF750CL)
   ---------------------------------------------------------
   Usage in any I/O decoder PLD:

   1. Define your actual address-decoded CS signals (ACIA1cs, TIMERcs, etc.)
   2. Paste this block after the CS equations
   3. Customize the *_SLOW_WAIT1/0 and *_FAST_WAIT1/0 constants below
      - 'b00 = 0 waits, 'b01 = 1 wait, 'b10 = 2 waits, 'b11 = 3 waits
   4. The final WAIT1/WAIT0 are automatically selected by SPEEDcurr (pin 4)
      - 0 = slow mode → uses *_SLOW_WAIT values
      - 1 = fast mode → uses *_FAST_WAIT values

   Example for this PLD (R65C52P3 ACIA):
     Slow (2 MHz E): 0 waits
     Fast (6 MHz E): 2 waits

   For other PLDs: just change the per-device SLOW/FAST values.
   ========================================================= */

/* -------- Speed select input (must be on pin 4 or change pin number) -------- */
PIN 4 = SPEEDcurr ;     /* 0 = slow mode, 1 = fast mode */

/* -------- Per-device wait codes - SLOW mode (edit per PLD) -------- */
ACIA_SLOW_WAIT1   = 'b0 ;
ACIA_SLOW_WAIT0   = 'b0 ;   /* 0 waits at 2 MHz E */

TIMER_SLOW_WAIT1  = 'b0 ;
TIMER_SLOW_WAIT0  = 'b0 ;

RTC_SLOW_WAIT1    = 'b0 ;
RTC_SLOW_WAIT0    = 'b0 ;

POST_SLOW_WAIT1   = 'b0 ;
POST_SLOW_WAIT0   = 'b0 ;

CONF_SLOW_WAIT1   = 'b0 ;
CONF_SLOW_WAIT0   = 'b0 ;

ROMDIS_SLOW_WAIT1 = 'b0 ;
ROMDIS_SLOW_WAIT0 = 'b0 ;

SPD_SLOW_WAIT1    = 'b0 ;
SPD_SLOW_WAIT0    = 'b0 ;

/* -------- Per-device wait codes - FAST mode (edit per PLD) -------- */
ACIA_FAST_WAIT1   = 'b1 ;
ACIA_FAST_WAIT0   = 'b0 ;   /* 2 waits at 6 MHz E */

TIMER_FAST_WAIT1  = 'b0 ;
TIMER_FAST_WAIT0  = 'b0 ;

RTC_FAST_WAIT1    = 'b0 ;
RTC_FAST_WAIT0    = 'b0 ;

POST_FAST_WAIT1   = 'b0 ;
POST_FAST_WAIT0   = 'b0 ;

CONF_FAST_WAIT1   = 'b0 ;
CONF_FAST_WAIT0   = 'b0 ;

ROMDIS_FAST_WAIT1 = 'b0 ;
ROMDIS_FAST_WAIT0 = 'b0 ;

SPD_FAST_WAIT1    = 'b0 ;
SPD_FAST_WAIT0    = 'b0 ;

/* -------- Mux: select slow or fast wait code per device -------- */
ACIA_WAIT1 = ( !SPEEDcurr & ACIA_SLOW_WAIT1 ) # ( SPEEDcurr & ACIA_FAST_WAIT1 ) ;
ACIA_WAIT0 = ( !SPEEDcurr & ACIA_SLOW_WAIT0 ) # ( SPEEDcurr & ACIA_FAST_WAIT0 ) ;

TIMER_WAIT1 = ( !SPEEDcurr & TIMER_SLOW_WAIT1 ) # ( SPEEDcurr & TIMER_FAST_WAIT1 ) ;
TIMER_WAIT0 = ( !SPEEDcurr & TIMER_SLOW_WAIT0 ) # ( SPEEDcurr & TIMER_FAST_WAIT0 ) ;

RTC_WAIT1   = ( !SPEEDcurr & RTC_SLOW_WAIT1 ) # ( SPEEDcurr & RTC_FAST_WAIT1 ) ;
RTC_WAIT0   = ( !SPEEDcurr & RTC_SLOW_WAIT0 ) # ( SPEEDcurr & RTC_FAST_WAIT0 ) ;

POST_WAIT1  = ( !SPEEDcurr & POST_SLOW_WAIT1 ) # ( SPEEDcurr & POST_FAST_WAIT1 ) ;
POST_WAIT0  = ( !SPEEDcurr & POST_SLOW_WAIT0 ) # ( SPEEDcurr & POST_FAST_WAIT0 ) ;

CONF_WAIT1  = ( !SPEEDcurr & CONF_SLOW_WAIT1 ) # ( SPEEDcurr & CONF_FAST_WAIT1 ) ;
CONF_WAIT0  = ( !SPEEDcurr & CONF_SLOW_WAIT0 ) # ( SPEEDcurr & CONF_FAST_WAIT0 ) ;

ROMDIS_WAIT1 = ( !SPEEDcurr & ROMDIS_SLOW_WAIT1 ) # ( SPEEDcurr & ROMDIS_FAST_WAIT1 ) ;
ROMDIS_WAIT0 = ( !SPEEDcurr & ROMDIS_SLOW_WAIT0 ) # ( SPEEDcurr & ROMDIS_FAST_WAIT0 ) ;

SPD_WAIT1   = ( !SPEEDcurr & SPD_SLOW_WAIT1 ) # ( SPEEDcurr & SPD_FAST_WAIT1 ) ;
SPD_WAIT0   = ( !SPEEDcurr & SPD_SLOW_WAIT0 ) # ( SPEEDcurr & SPD_FAST_WAIT0 ) ;

/* -------- Final WAIT1/WAIT0 mux (one-hot CS assumed) -------- */
WAIT1 = (ACIA1cs  & ACIA_WAIT1)   #
        (TIMERcs  & TIMER_WAIT1)  #
        (RTCcs    & RTC_WAIT1)    #
        (POSTcs   & POST_WAIT1)   #
        (CONFcs   & CONF_WAIT1)   #
        (ROMdis   & ROMDIS_WAIT1) #
        (SPDsel   & SPD_WAIT1)    ;

WAIT0 = (ACIA1cs  & ACIA_WAIT0)   #
        (TIMERcs  & TIMER_WAIT0)  #
        (RTCcs    & RTC_WAIT0)    #
        (POSTcs   & POST_WAIT0)   #
        (CONFcs   & CONF_WAIT0)   #
        (ROMdis   & ROMDIS_WAIT0) #
        (SPDsel   & SPD_WAIT0)    ;

/* -------- Counter logic (unchanged - copy as-is) -------- */
CYCLE_ACTIVE = !IORQ ;

[C3..C0].CLK = CPUclk ;

L3 = WAIT1 ;
L2 = WAIT1 ;
L1 = WAIT0 ;
L0 = 'b0 ;

COUNT_EN = (C3 # C2 # C1 # C0) & CYCLE_ACTIVE ;

LOAD = CYCLE_ACTIVE & (WAIT1 # WAIT0) & !(C3 # C2 # C1 # C0) ;

BORROW3 = C2 & C1 & C0 ;
BORROW2 = C1 & C0 ;
BORROW1 = C0 ;

C3.D = (LOAD & L3) # (COUNT_EN & (C3 $ BORROW3)) ;
C2.D = (LOAD & L2) # (COUNT_EN & (C2 $ BORROW2)) ;
C1.D = (LOAD & L1) # (COUNT_EN & (C1 $ BORROW1)) ;
C0.D = (LOAD & L0) # (COUNT_EN & !C0) ;

ASSERT = C3 # C2 # C1 # C0 ;

[C3..C0].AR = !CYCLE_ACTIVE ;

!MRDYout = !ASSERT ;