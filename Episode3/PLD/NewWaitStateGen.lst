LISTING FOR LOGIC DESCRIPTION FILE: NewWaitStateGen.pld              Page 1

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# MW-10400000
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Feb 06 06:28:38 2026

  1:Name     NewWaitStateGen ;
  2:PartNo   ATF750CL ;
  3:Date     2025/12/11 ;
  4:Revision 2 ;
  5:Designer Frederic Segard ;
  6:Company  MicroHobbyist ;
  7:Assembly None ;
  8:Location None ;
  9:Device   v750c ;
 10:
 11:/* =========================================================
 12:   6309 WAIT-STATE STRETCHER (ATF750C VERSION)
 13:   ---------------------------------------------------------
 14:   - Supports true 0..3 wait states from TWO sources:
 15:       * WS[1:0] from I/O decoder PLDs (shared bus).
 16:       * D[1:0] from speed register (CPU call).
 17:     Effective wait = max(WS_IO or WS_SPD).
 18:
 19:   - Quarter-cycle timing using CLK4x (4x E).
 20:   - 1 wait state = 4 quarter cycles (CNT3..0).
 21:   - /MRDY held LOW while counter > 0 OR external waits.
 22:   - External waits (WAIT1, WAIT3..3, WAIT2) can hold
 23:     /MRDY as long as they remain active.
 24:   - Speed register is read/write via SPDsel & D1:D0.
 25:   ========================================================= */
 26:
 27:/* ------------------------- INPUTS ------------------------- */
 28:PIN  1 =  CLK4x ;     /* 4x clock */
 29:PIN  2 =  E ;         /* CPU E */
 30:PIN  3 =  RW ;        /* Read/Write line */
 31:PIN  4 = !RESET ;     /* System reset, active low */
 32:PIN  5 = !WAIT1 ;     /* External wait 1, active low at pin */
 33:PIN  6 = !WAIT2 ;     /* External wait 2, active low at pin */
 34:PIN  7 = !WAIT3 ;     /* External wait 3, active low at pin */
 35:PIN  8 = !WAIT4 ;     /* External wait 4, active low at pin */
 36:PIN  9 = !WAIT5 ;     /* External wait 5, active low at pin */
 37:PIN 10 = !SPDsel ;    /* Speed register chip select, active LOW at pin */
 38:PIN 11 =  WS0 ;       /* I/O bus wait-state bit 0 (pulled low) */
 39:/*  12 =  GND ;       /* Ground */
 40:PIN 13 =  WS1 ;       /* I/O bus wait-state bit 1 (pulled low) */
 41:
 42:/* ------------------------- OUTPUTS ------------------------ */
 43:/*  24 =  VCC ;       /* +5V */
 44:PIN 23 = !MRDY ;      /* MRDY to CPU, active LOW */
 45:PIN 22 =  CNT0 ;      /* NC - Counter bit 0 (debug) */
 46:PIN 21 =  CNT1 ;      /* NC - Counter bit 1 (debug) */
 47:PIN 20 =  CNT2 ;      /* NC - Counter bit 2 (debug) */
 48:PIN 19 =  CNT3 ;      /* NC - Counter bit 3 (debug) */
 49:PIN 18 =  RUN ;       /* NC - Stretch active (debug) */
 50:PIN 17 =  S0 ;        /* Speed register bit 0 (latched) + BiColor LED */
 51:PIN 16 =  S1 ;        /* Speed register bit 1 (latched) + BiColor LED */
 52:
 53:/* ------------------------- BIDIRECTIONAL ------------------ */

LISTING FOR LOGIC DESCRIPTION FILE: NewWaitStateGen.pld              Page 2

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# MW-10400000
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Feb 06 06:28:38 2026

 54:PIN 15 =  D0 ;        /* Data bus bit 0 (bidirectional) */
 55:PIN 14 =  D1 ;        /* Data bus bit 1 (bidirectional) */
 56:
 57:/* ----------------------- BURIED NODES --------------------- */
 58:
 59:PINNODE 25 = E_prev ;        /* Previous E (synced) */
 60:PINNODE 26 = E_sync ;        /* Synchronized E */
 61:PINNODE 27 = WAIT_NZ_prev ;  /* Previous WAIT_NZ (effective WS) */
 62:PINNODE 28 = HOLD ;          /* Hold latch */
 63:
 64:/* =========================================================
 65:   SPEED REGISTER (GLOBAL "SLOWDOWN" IN WS UNITS)
 66:   ---------------------------------------------------------
 67:   - 2-bit register S1:S0 written at SPDsel address.
 68:   - REG_WRITE when SPDsel is asserted and R/W=0.
 69:   - Register is clocked by CLK4x (single global clock),
 70:     using simple "hold or write" logic.
 71:   - On reset, S1 and S0 clear to 0 (no extra WS).
 72:   ========================================================= */
 73:
 74:REG_WRITE = SPDsel & !RW ;   /* SPDsel=1 internally when pin is low */
 75:REG_READ  = SPDsel &  RW ;   /* Readback of S1:S0 onto D1:D0 */
 76:
 77:/* S0: speed bit 0 */
 78:S0.d  = (REG_WRITE & D0) # (!REG_WRITE & S0) ;
 79:S0.ck = CLK4x ;
 80:S0.ar = RESET ;    /* Clear to 0 on reset */
 81:S0.sp = 'b'0 ;
 82:
 83:/* S1: speed bit 1 */
 84:S1.d  = (REG_WRITE & D1) # (!REG_WRITE & S1) ;
 85:S1.ck = CLK4x ;
 86:S1.ar = RESET ;    /* Clear to 0 on reset */
 87:S1.sp = 'b'0 ;
 88:
 89:/* If I want to start the PLD at a specific speed on RESET
 90:
 91:S0.d  = (RESET & 'b'0) # (!RESET & ((REG_WRITE & D0) # (!REG_WRITE & S0))) ;
 92:S0.ck = CLK4x ;
 93:S0.ar = 'b'0 ;
 94:S0.sp = 'b'0 ;
 95:
 96:S1.d  = (RESET & 'b'1) # (!RESET & ((REG_WRITE & D1) # (!REG_WRITE & S1))) ;
 97:S1.ck = CLK4x ;
 98:S1.ar = 'b'0 ;
 99:S1.sp = 'b'0 ;
100:
101:*/
102:
103:/* =========================================================
104:   E SYNCHRONIZERS (CLK4x DOMAIN)
105:   ========================================================= */
106:
107:E_sync.d  = E ;

LISTING FOR LOGIC DESCRIPTION FILE: NewWaitStateGen.pld              Page 3

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# MW-10400000
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Feb 06 06:28:38 2026

108:E_sync.ck = CLK4x ;
109:E_sync.ar = RESET ;
110:E_sync.sp = 'b'0 ;
111:
112:E_prev.d  = E_sync ;
113:E_prev.ck = CLK4x ;
114:E_prev.ar = RESET ;
115:E_prev.sp = 'b'0 ;
116:
117:/* E rising-edge detect */
118:E_rise = E_sync & !E_prev ;
119:
120:/* =========================================================
121:   EXTERNAL WAIT SOURCES
122:   ---------------------------------------------------------
123:   Inputs are active LOW at the pin. Internally they are
124:   active HIGH when a wait is requested.
125:   ========================================================= */
126:
127:EXT_WAIT = WAIT1 # WAIT2 # WAIT3 # WAIT4 # WAIT5 ;
128:
129:/* =========================================================
130:   EFFECTIVE WAIT-STATE VALUE (0..3) AND PRELOAD (WS * 4)
131:   ---------------------------------------------------------
132:   WS_IO[1:0] comes from I/O decoders on the shared bus.
133:   WS_SPD[1:0] comes from local speed register S1:S0.
134:
135:   We compute:
136:     WS_EFF = max(WS_IO, WS_SPD)
137:
138:   Truth table for max(2-bit, 2-bit):
139:
140:   WS_SPD WS_IO | WS_EFF
141:   00     00    | 00
142:   00     01    | 01
143:   00     10    | 10
144:   00     11    | 11
145:   01     00    | 01
146:   01     01    | 01
147:   01     10    | 10
148:   01     11    | 11
149:   10     00    | 10
150:   10     01    | 10
151:   10     10    | 10
152:   10     11    | 11
153:   11     00    | 11
154:   11     01    | 11
155:   11     10    | 11
156:   11     11    | 11
157:   ========================================================= */
158:
159:/* MSB of effective wait = OR of MSBs */
160:WS_eff1 = WS1 # S1 ;
161:

LISTING FOR LOGIC DESCRIPTION FILE: NewWaitStateGen.pld              Page 4

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# MW-10400000
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Feb 06 06:28:38 2026

162:/* LSB of effective wait = max function */
163:WS_eff0 =
164:     (WS0 & WS1)     /* IO = 3 */
165:   # (S0 & S1)       /* SPD = 3 */
166:   # (WS0 & !S1)     /* IO >= 1 and SPD < 2 */
167:   # (S0 & !WS1) ;   /* SPD >= 1 and IO < 2 */
168:
169:/* Non-zero effective WS */
170:WAIT_NZ = WS_eff0 # WS_eff1 ;
171:
172:/* Track WAIT_NZ changes (based on effective WS) */
173:WAIT_NZ_prev.d  = WAIT_NZ ;
174:WAIT_NZ_prev.ck = CLK4x ;
175:WAIT_NZ_prev.ar = RESET ;
176:WAIT_NZ_prev.sp = 'b'0 ;
177:
178:/* Detect when WS_EFF becomes non-zero while E is high */
179:WAIT_RISE = WAIT_NZ & !WAIT_NZ_prev ;
180:
181:/* Preload = WS_EFF * 4 (shift left 2 bits)
182:   WS_EFF[1:0] -> {CNT3..0} = {WS1, WS0, 0, 0}
183:   so 1WS => 0100, 2WS => 1000, 3WS => 1100.
184:*/
185:LOAD0 = 'b'0 ;
186:LOAD1 = 'b'0 ;
187:LOAD2 = WS_eff0 ;
188:LOAD3 = WS_eff1 ;
189:
190:/* =========================================================
191:   RUN CONTROL AND DOWN COUNTER (4 BITS)
192:   ========================================================= */
193:
194:CNT_ZERO = !CNT3 & !CNT2 & !CNT1 & !CNT0 ;
195:
196:/* Load when:
197:   - E rises and WS_EFF != 0, OR
198:   - WS_EFF becomes non-zero while E is high.
199:*/
200:LOAD = (E_rise & WAIT_NZ & !RUN) #
201:       (E_sync & WAIT_RISE & !RUN) ;
202:
203:/* RUN while counter not zero */
204:RUN.d  = LOAD # (RUN & !CNT_ZERO) ;
205:RUN.ck = CLK4x ;
206:RUN.ar = RESET ;
207:RUN.sp = 'b'0 ;
208:
209:/* Decrement enable */
210:DEC = RUN & !CNT_ZERO ;
211:
212:/* --------------- 4-bit DOWN COUNTER (CNT3..CNT0) --------------- */
213:
214:CNT0.d = (LOAD & LOAD0) # (!LOAD & (DEC $ CNT0)) ;
215:CNT0.ck = CLK4x ;

LISTING FOR LOGIC DESCRIPTION FILE: NewWaitStateGen.pld              Page 5

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# MW-10400000
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Feb 06 06:28:38 2026

216:CNT0.ar = RESET ;
217:CNT0.sp = 'b'0 ;
218:
219:CNT1.d = (LOAD & LOAD1) # (!LOAD & ((DEC & !CNT0) $ CNT1)) ;
220:CNT1.ck = CLK4x ;
221:CNT1.ar = RESET ;
222:CNT1.sp = 'b'0 ;
223:
224:CNT2.d = (LOAD & LOAD2) # (!LOAD & ((DEC & !CNT1 & !CNT0) $ CNT2)) ;
225:CNT2.ck = CLK4x ;
226:CNT2.ar = RESET ;
227:CNT2.sp = 'b'0 ;
228:
229:CNT3.d = (LOAD & LOAD3) # (!LOAD & ((DEC & !CNT2 & !CNT1 & !CNT0) $ CNT3)) ;
230:CNT3.ck = CLK4x ;
231:CNT3.ar = RESET ;
232:CNT3.sp = 'b'0 ;
233:
234:/* =========================================================
235:   DATA BUS READBACK (SPEED REGISTER)
236:   ========================================================= */
237:
238:D0    = REG_READ & S0 ;
239:D0.oe = REG_READ ;
240:
241:D1    = REG_READ & S1 ;
242:D1.oe = REG_READ ;
243:
244:MRDY.oe = 'b'1 ;
245:S0.oe   = 'b'1 ;
246:S1.oe   = 'b'1 ;
247:
248:/* =========================================================
249:   SIMPLIFIED MRDY OUTPUT
250:   ---------------------------------------------------------
251:   - MRDY is active while:
252:       * internal wait counter is running (RUN = 1), OR
253:       * any external wait source is active (EXT_WAIT = 1).
254:   - No HOLD latch: avoids "stuck low" condition.
255:   ========================================================= */
256:
257:MRDY = RUN # EXT_WAIT ;
258:



Jedec Fuse Checksum       (e0b7)
Jedec Transmit Checksum   (e4fb)
