Name     WaitStateGen ;
PartNo   ATF750C ;
Date     2025/11/22 ;
Revision 8 ;
Designer Frederic Segard ;
Company  MicroHobbyist ;
Assembly None ;
Location None ;
Device   v750c ;

/* =========================================================
   6309 WAIT-STATE STRETCHER (ATF750C VERSION)
   ---------------------------------------------------------
   Supports true 0..7 wait states (WS2..WS0).
   Quarter-cycle timing using CLK4x.
   1 wait state = 4 quarter cycles.
   Preload = WS * 4 = 0..28.
   5-bit down counter (CNT4..CNT0) handles 0..31.
   MRDY held low while counter > 0.
   ========================================================= */

/* ------------------------- INPUTS ------------------------- */
PIN  1 =  CLK4x ;    /* 4x EXTAL clock input */
PIN  2 =  E ;        /* CPU E */
PIN  3 =  RW ;       /* CPU R W */
PIN  4 = !RESET ;    /* System reset, active low */
PIN  5 = !VDPWAIT ;  /* VDP wait, active low */
PIN  6 = !PSGDT ;    /* PSG dtack OR, active low */
PIN  7 = !WAIT1 ;    /* External wait 1 */
PIN  8 = !WAIT2 ;    /* External wait 2 */
PIN  9 = !WAIT3 ;    /* External wait 3 */
PIN 10 =  WS0 ;      /* Wait state bit 0 */
PIN 11 =  WS1 ;      /* Wait state bit 1 */
/*  12 =  GND ;      /* Connected to ground */
PIN 13 =  WS2 ;      /* Wait state bit 2 */

/* ------------------------- OUTPUTS ------------------------ */
/*  24 =  VCC ;      /* Connected to +5V */
PIN 23 = !MRDY ;     /* MRDY to CPU, active low */
PIN 17 =  RUN ;      /* Stretch active (Not enough PT on buried nodes) */
PIN 22 =  CNT0 ;     /* Counter bit 0 (Not enough PT on buried nodes) */
PIN 20 =  CNT1 ;     /* Counter bit 1 (Not enough PT on buried nodes) */
PIN 19 =  CNT2 ;     /* Counter bit 2 (Not enough PT on buried nodes) */
PIN 18 =  CNT3 ;     /* Counter bit 3 (Not enough PT on buried nodes) */
PIN 21  = CNT4 ;     /* Counter bit 4 (Not enough PT on buried nodes) */

/* ----------------------- BURIED NODES --------------------- */

PINNODE 25 =  E_prev ;  /* Previous E (synced) */
PINNODE 26 =  E_sync ;  /* Synchronized E */
PINNODE 27 =  WAIT_NZ_prev ;
PINNODE 31 =  HOLD ;

/* =========================================================
   E SYNCHRONIZERS (CLK4X DOMAIN)
   ========================================================= */

E_sync.d  = E ;
E_sync.ck = CLK4x ;
E_sync.ar = RESET ;
E_sync.sp = 'b'0 ;

E_prev.d  = E_sync ;
E_prev.ck = CLK4x ;
E_prev.ar = RESET ;
E_prev.sp = 'b'0 ;

/* Rising-edge detect */
E_rise = E_sync & !E_prev ;

WAIT_NZ_prev.d  = WAIT_NZ ;
WAIT_NZ_prev.ck = CLK4x ;
WAIT_NZ_prev.ar = RESET ;
WAIT_NZ_prev.sp = 'b'0 ;

WAIT_RISE = WAIT_NZ & !WAIT_NZ_prev ;

/* =========================================================
   EXTERNAL WAIT SOURCES
   ========================================================= */

/* These inputs are active low at the pin. Internal EXT_WAIT is active high. */
EXT_WAIT = VDPWAIT # PSGDT # WAIT1 # WAIT2 # WAIT3 ;

/* =========================================================
   WAIT-STATE VALUE (0..7) AND PRELOAD (WS * 4)
   ========================================================= */

/* Raw WS bits */
WS_NUM0 = WS0 ;
WS_NUM1 = WS1 ;
WS_NUM2 = WS2 ;

/* Non-zero WS request */
WAIT_NZ = WS_NUM0 # WS_NUM1 # WS_NUM2 ;

/* Preload = WS * 4 (shift left by two) */
LOAD0 = 'b'0 ;
LOAD1 = 'b'0 ;
LOAD2 = WS_NUM0 ;
LOAD3 = WS_NUM1 ;
LOAD4 = WS_NUM2 ;

/* =========================================================
   RUN CONTROL AND DOWN COUNTER (5 BITS)
   ========================================================= */

CNT_ZERO = !CNT4 & !CNT3 & !CNT2 & !CNT1 & !CNT0 ;

LOAD = (E_rise  & WAIT_NZ & !RUN) #
       (E_sync  & WAIT_RISE & !RUN) ;

/* RUN stays active while counter not zero */
RUN.d  = LOAD # (RUN & !CNT_ZERO) ;
RUN.ck = CLK4x ;
RUN.ar = RESET ;
RUN.sp = 'b'0 ;

/* Decrement when RUN is active */
DEC = RUN & !CNT_ZERO ;

/* ---------------- 5-bit down counter ---------------------- */

CNT0.d = (LOAD & LOAD0) # (!LOAD & (DEC $ CNT0)) ;
CNT0.ck = CLK4x ;
CNT0.ar = RESET ;
CNT0.sp = 'b'0 ;

CNT1.d = (LOAD & LOAD1) # (!LOAD & ((DEC & !CNT0) $ CNT1)) ;
CNT1.ck = CLK4x ;
CNT1.ar = RESET ;
CNT1.sp = 'b'0 ;

CNT2.d = (LOAD & LOAD2) # (!LOAD & ((DEC & !CNT1 & !CNT0) $ CNT2)) ;
CNT2.ck = CLK4x ;
CNT2.ar = RESET ;
CNT2.sp = 'b'0 ;

CNT3.d = (LOAD & LOAD3) # (!LOAD & ((DEC & !CNT2 & !CNT1 & !CNT0) $ CNT3)) ;
CNT3.ck = CLK4x ;
CNT3.ar = RESET ;
CNT3.sp = 'b'0 ;

CNT4.d  =(LOAD & LOAD4) # (!LOAD & ((DEC & !CNT3 & !CNT2 & !CNT1 & !CNT0) $ CNT4)) ;
CNT4.ck = CLK4x ;
CNT4.ar = RESET ;
CNT4.sp = 'b'0 ;

/* =========================================================
   HOLD LATCH TO EXTEND MRDY THROUGH END OF CYCLE
   ========================================================= */

HOLD.d  = RUN # (HOLD & !E_rise) ;
HOLD.ck = CLK4x ;
HOLD.ar = RESET ;
HOLD.sp = 'b'0 ;

/* =========================================================
   OUTPUTS
   ========================================================= */

/* Internal busy=1 -> pin !MRDY low when busy. */
MRDY = HOLD # EXT_WAIT ;

