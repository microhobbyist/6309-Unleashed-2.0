Name     WaitStateGen ;
PartNo   ATF750CL ;
Date     2025/11/28 ;
Revision 12 ;
Designer Frederic Segard ;
Company  MicroHobbyist ;
Assembly None ;
Location None ;
Device   v750c ;

/* =========================================================
   6309 WAIT-STATE STRETCHER (ATF750C VERSION)
   ---------------------------------------------------------
   Supports true 0..3 wait states (WS1..WS0).
   Quarter-cycle timing using CPUclk.
   1 wait state = 4 quarter cycles.
   4-bit down counter CNT3..CNT0 (0..15 range).
   MRDY held low while counter > 0.
   External wait requests OR-in.
   ========================================================= */

/* ------------------------- INPUTS ------------------------- */
PIN  1 =  CPUclk ;    /* 4x clock from CPU Speed Selector PLD */
PIN  2 =  E ;         /* CPU E */
PIN  3 =  RW ;        /* CPU R/W */
PIN  4 = !RESET ;     /* System reset, active low */
PIN  5 = !MREQ ;      /* Memory Request */
PIN  6 = !VDPWAIT ;   /* VDP wait, active low */
PIN  7 = !PSGDT ;     /* PSG dtack OR, active low */
PIN  8 = !WAIT1 ;     /* External wait 1 */
PIN  9 = !WAIT2 ;     /* External wait 2 */
PIN 10 = !WAIT3 ;     /* External wait 3 */
PIN 11 =  WS0 ;       /* Wait-state bit 0 */
/*  12 =  GND */
PIN 13 =  WS1 ;       /* Wait-state bit 1 */
PIN 14 = !ROMdis ;    /* ROM disable chip select */

/* ------------------------- OUTPUTS ------------------------ */
/*  24 =  VCC */
PIN 23 = !MRDY ;      /* MRDY to CPU, active low */
PIN 22 =  CNT0 ;      /* NC - Counter bit 0 (debug) */
PIN 21 =  CNT1 ;      /* NC - Counter bit 1 (debug) */
PIN 20 =  CNT2 ;      /* NC - Counter bit 2 (debug) */
PIN 19 =  CNT3 ;      /* NC - Counter bit 3 (debug) */
PIN 18 =  RUN ;       /* NC - Stretch active (debug) */
/*  17 =  NC ;        /* Not connected */
PIN 16 = !ROMcs ;     /* ROM chip select, valid until !ROMdis */
PIN 15 = !RAMoe ;     /* RAM output enable, valid when !ROMdis */

/* ----------------------- BURIED NODES --------------------- */

PINNODE 25 = E_prev ;        /* Previous E (synced) */
PINNODE 26 = E_sync ;        /* Synchronized E */
PINNODE 27 = WAIT_NZ_prev ;  /* Previous WAIT_NZ */
PINNODE 28 = ROMdisFF ;      /* ROM disable */
PINNODE 29 = HOLD ;          /* Hold latch */

/* =========================================================
                 SHADOW ROM LOGIC
   ========================================================= */

ROMdisFF.d  = 'b'1 ;
ROMdisFF.ck = ROMdis ;
ROMdisFF.ar = RESET ;
ROMdisFF.sp = 'b'0 ;

ROMcs  =  !MREQ #  ROMdisFF ;
RAMoe  =  !(RW & E) # !ROMdisFF ;

/* =========================================================
   E SYNCHRONIZERS (CPUclk DOMAIN)
   ========================================================= */

E_sync.d  = E ;
E_sync.ck = CPUclk ;
E_sync.ar = RESET ;
E_sync.sp = 'b'0 ;

E_prev.d  = E_sync ;
E_prev.ck = CPUclk ;
E_prev.ar = RESET ;
E_prev.sp = 'b'0 ;

/* E rising-edge detect */
E_rise = E_sync & !E_prev ;

/* Track WAIT_NZ changes */
WAIT_NZ_prev.d  = WAIT_NZ ;
WAIT_NZ_prev.ck = CPUclk ;
WAIT_NZ_prev.ar = RESET ;
WAIT_NZ_prev.sp = 'b'0 ;

/* Detect when WS value changes during E high */
WAIT_RISE = WAIT_NZ & !WAIT_NZ_prev ;

/* =========================================================
   EXTERNAL WAIT SOURCES
   ========================================================= */

EXT_WAIT = VDPWAIT # PSGDT # WAIT1 # WAIT2 # WAIT3 ;

/* =========================================================
   WAIT-STATE VALUE (0..3) AND PRELOAD (WS * 4)
   ========================================================= */

WS_NUM0 = WS0 ;
WS_NUM1 = WS1 ;

/* Non-zero WS */
WAIT_NZ = WS_NUM0 # WS_NUM1 ;

/* Preload = WS * 4 (shift left 2 bits) */
LOAD0 = 'b'0 ;
LOAD1 = 'b'0 ;
LOAD2 = WS_NUM0 ;
LOAD3 = WS_NUM1 ;

/* =========================================================
   RUN CONTROL AND DOWN COUNTER (4 BITS)
   ========================================================= */

CNT_ZERO = !CNT3 & !CNT2 & !CNT1 & !CNT0 ;

/* Load when:
   - E rises and WS != 0
   - OR WS becomes nonzero while E is high
*/
LOAD = (E_rise & WAIT_NZ & !RUN) #
       (E_sync & WAIT_RISE & !RUN) ;

/* RUN while counter not zero */
RUN.d  = LOAD # (RUN & !CNT_ZERO) ;
RUN.ck = CPUclk ;
RUN.ar = RESET ;
RUN.sp = 'b'0 ;

/* Decrement enable */
DEC = RUN & !CNT_ZERO ;

/* --------------- 4-bit DOWN COUNTER (CNT3..CNT0) --------------- */

CNT0.d = (LOAD & LOAD0) # (!LOAD & (DEC $ CNT0)) ;
CNT0.ck = CPUclk ;
CNT0.ar = RESET ;
CNT0.sp = 'b'0 ;

CNT1.d = (LOAD & LOAD1) # (!LOAD & ((DEC & !CNT0) $ CNT1)) ;
CNT1.ck = CPUclk ;
CNT1.ar = RESET ;
CNT1.sp = 'b'0 ;

CNT2.d = (LOAD & LOAD2) # (!LOAD & ((DEC & !CNT1 & !CNT0) $ CNT2)) ;
CNT2.ck = CPUclk ;
CNT2.ar = RESET ;
CNT2.sp = 'b'0 ;

CNT3.d = (LOAD & LOAD3) # (!LOAD & ((DEC & !CNT2 & !CNT1 & !CNT0) $ CNT3)) ;
CNT3.ck = CPUclk ;
CNT3.ar = RESET ;
CNT3.sp = 'b'0 ;

/* =========================================================
   HOLD LATCH - EXTEND MRDY UNTIL END OF E CYCLE
   ========================================================= */

HOLD.d  = RUN # (HOLD & !E_rise) ;
HOLD.ck = CPUclk ;
HOLD.ar = RESET ;
HOLD.sp = 'b'0 ;

/* =========================================================
   OUTPUT
   ========================================================= */

MRDY = HOLD # EXT_WAIT ;

