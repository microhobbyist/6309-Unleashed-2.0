Name      CPUSpeedSel ;
PartNo    ATF750CL ;
Date      2025/11/28 ;
Revision  17 ;
Designer  Frederic Segard ;
Company   MicroHobbyist ;
Assembly  None ;
Location  None ;
Device    v750c ;

/* INPUTS */
PIN  1 =  CLK4x ;    /* 16 MHz system oscillator */
PIN  2 =  E ;        /* CPU E (from 6309) */
PIN  3 =  RW ;       /* 1=read, 0=write */
PIN  4 = !RESET ;    /* Active-low reset */
PIN  5 = !SPDsel ;   /* Speed Select chip select */
PIN  6 =  BA ;       /* Bus Available */
PIN  7 =  BS ;       /* Bus Status */
PIN  8 = !HALTin ;   /* External halt input */
PIN  9 = !PAUSEsw ;  /* Pause switch (experimental) */
PIN 10 =  S0init ;   /* DIP switch for startup speed bit 0 */
PIN 11 =  S1init ;   /* DIP switch for startup speed bit 1 */
/*  12 =  GND ;      /* Ground */
/*  13 =  GND ;      /* Tied to ground */

/* OUTPUTS */
/*  24 =  VCC */
PIN 23 =  LED_R ;
PIN 22 =  LED_G ;
PIN 21 =  LED_B ;
PIN 20 = !HALTout ;  /* Halt request to CPU */
PIN 19 =  CPUclk ;   /* Chosen CPU clock speed (pin 38) */
PIN 18 =  H3 ;       /* No connect (debug) */
/*  17 =  NC ;       /* No connect */
PIN 16 =  CPUstp ;   /* CPU is halted or bus granted - BA/BS = 1 */

/* BIDIRECTIONAL (Data Bus) */
PIN 15 =  D0 ;
PIN 14 =  D1 ;

/* BURIED NODES */
PINNODE 25 = DIV2 ;
PINNODE 26 = DIV4 ;
PINNODE 27 = DIV8 ;
PINNODE 33 = S0 ;
PINNODE 32 = S1 ;
PINNODE 28 = H0 ;
PINNODE 29 = H1 ;
PINNODE 34 = H2 ;

CPUstp = BA & BS ;   /* LED turns on whenever CPU is stopped */

/* =========================================================
                   SPEED REGISTER (DIP + E-qualified)
   ---------------------------------------------------------
   ALL flip-flops use the global clock (CLK4x), as required
   by the ATF750C.  Updates occur on E=1 using clock-enable
   logic instead of gated clocks.
========================================================= */

/* RESET is active-low input, so RESET=0 means "in reset" */
/* DIP switches produce S0init and S1init on pins 10 and 11 */

REG_WRITE = SPDsel & !RW ;

/* Next-state equations using clock-enable logic */
S0_next =
    (RESET & S0init) #                   /* Preload from DIP during reset */
    (!RESET & E & REG_WRITE & D0) #     /* Write new bit */
    (!RESET & E & !REG_WRITE & S0) #    /* Hold on read cycle while E=1 */
    (!RESET & !E & S0);                 /* Hold when E=0 */

S1_next =
    (RESET & S1init) #                   /* Preload from DIP during reset */
    (!RESET & E & REG_WRITE & D1) #     /* Write new bit */
    (!RESET & E & !REG_WRITE & S1) #    /* Hold on read cycle while E=1 */
    (!RESET & !E & S1);                 /* Hold when E=0 */

/* ---------------------------
   FLIP-FLOPS
---------------------------- */

S0.d  = S0_next ;
S1.d  = S1_next ;

S0.ck = CLK4x ;
S1.ck = CLK4x ;

S0.ar = 'b'0 ;
S1.ar = 'b'0 ;

S0.sp = 'b'0 ;
S1.sp = 'b'0 ;


/* =========================================================
                   CLOCK DIVIDERS
========================================================= */

DIV2.d  = !DIV2 ;
DIV4.d  =  DIV4 $ DIV2 ;
DIV8.d  =  DIV8 $ (DIV2 & DIV4) ;

DIV2.ck = CLK4x ;
DIV4.ck = CLK4x ;
DIV8.ck = CLK4x ;

DIV2.ar = RESET ;
DIV4.ar = RESET ;
DIV8.ar = RESET ;

DIV2.sp = 'b'0 ;
DIV4.sp = 'b'0 ;
DIV8.sp = 'b'0 ;

/* =========================================================
                   SPEED STATES
========================================================= */

SPD_TURBO  =  S1 &  S0 ;
SPD_FAST   =  S1 & !S0 ;
SPD_NORMAL = !S1 &  S0 ;
SPD_SLOW   = !S1 & !S0 ;

/* =========================================================
                   RAW CLOCK (MUX BEFORE SAFE HOLD)
========================================================= */

NEW_CLK =
     (SPD_TURBO  & CLK4x) #
     (SPD_FAST   & DIV2 ) #
     (SPD_NORMAL & DIV4 ) #
     (SPD_SLOW   & DIV8 ) ;

/* =========================================================
                      RGB LED OUTPUTS
========================================================= */

LED_R = SPD_TURBO  # SPD_FAST ;
LED_G = SPD_NORMAL # SPD_FAST ;
LED_B = SPD_SLOW ;

/* =========================================================
                        HALT LOGIC
========================================================= */

CHANGE_S1 = (REG_WRITE &  D1 & !S1) # (REG_WRITE & !D1 &  S1) ;
CHANGE_S0 = (REG_WRITE &  D0 & !S0) # (REG_WRITE & !D0 &  S0) ;

HALT_ACTIVE = CHANGE_S1 # CHANGE_S0 ;

/* 3-cycle stretch for safe switching */

H0.d = HALT_ACTIVE ;
H1.d = H0 ;
H2.d = H1 ;
H3.d = H2 ;

H0.ck = CLK4x ;
H1.ck = CLK4x ;
H2.ck = CLK4x ;
H3.ck = CLK4x ;

H0.ar = RESET ;
H1.ar = RESET ;
H2.ar = RESET ;
H3.ar = RESET ;

H0.sp = 'b'0 ;
H1.sp = 'b'0 ;
H2.sp = 'b'0 ;
H3.sp = 'b'0 ;

HALT_SPEED_STRETCHED = HALT_ACTIVE # H0 # H1 # H2 # H3 ;

HALTout = HALTin # PAUSEsw # HALT_SPEED_STRETCHED ;

/* =========================================================
                SAFE CLOCK SWITCHING (NEW LOGIC)
   ---------------------------------------------------------
   Only switch clock when HALT=1 AND BA=1 AND BS=1.
   Otherwise CPUclk keeps last output (legal feedback).
========================================================= */

SAFE = HALTout & BA & BS ;

/* CUPL-safe high-level gate: */
CPUclk = (!SAFE & NEW_CLK) # (SAFE & CPUclk) ;

/* =========================================================
                     TRI-STATE READBACK LOGIC
========================================================= */

REG_READ = SPDsel & RW ;

D1 = REG_READ & S1 ;
D1.oe = REG_READ ;

D0 = REG_READ & S0 ;
D0.oe = REG_READ ;

CPUclk.oe  = 'b'1 ;
CPUstp.oe  = 'b'1 ;
HALTout.oe = 'b'1 ;
LED_B.oe   = 'b'1 ;
LED_G.oe   = 'b'1 ;
LED_R.oe   = 'b'1 ;
