Name     CPUSpeedSel ;
PartNo   ATF750CL ;
Date     2025/11/22 ;
Revision 14 ;
Designer Frederic Segard ;
Company  MicroHobbyist ;
Assembly None ;
Location None ;
Device   v750c ;

/* INPUTS */
PIN  1 =  CLK4x ;    /* 16 MHz system oscillator */
PIN  2 =  E ;        /* CPU E (from 6309) */
PIN  3 =  RW ;       /* 1=read, 0=write */
PIN  4 = !RESET ;    /* Active-low reset */
PIN  5 =  MREQ ;     /* Memory Request */
PIN  6 = !ROMdis ;   /* External ROM disable */
PIN  7 = !SPDsel ;   /* Speed reg chip select (active low) */
PIN  8 = !HALTin ;   /* External halt input (active low at pin) */
PIN  9 = !PAUSEsw ;  /* Pause switch (active low at pin) */
PIN 10 = !ROMaddr ;  /* Future expansion */
PIN 11 =  RAMaddr ;  /* Future expansion */
/*  12 =  GND */
/*  13 =  GND ;      /* No connect - Grounded */

/* DATA BUS (bidirectional) */
PIN 15 =  D0 ;       /* Speed bit 0 */
PIN 14 =  D1 ;       /* Speed bit 1 */

/* OUTPUTS */
PIN 23 =  CPUclk ;   /* EXTAL -> CPU */
PIN 22 = !HALTout ;  /* HALT to CPU (active low) */
PIN 21 =  LED_R ;
PIN 20 =  LED_G ;
PIN 19 =  LED_B ;
PIN 18 =  RAMcs ;    /* Future expansion */
PIN 17 =  ROMcs ;
PIN 16 =  RAMoe ;
/* 24 = VCC */

/* BURIED NODES */
PINNODE 25 = DIV2 ;
PINNODE 26 = DIV4 ;
PINNODE 27 = DIV8 ;
PINNODE 31 = S0 ;
PINNODE 32 = S1 ;
PINNODE 33 = ROMdisFF ;

/* =========================================================
                 SHADOW ROM LOGIC
   ========================================================= */

ROMdisFF.d  = 'b'1 ;
ROMdisFF.ck = ROMdis ;
ROMdisFF.ar = RESET ;
ROMdisFF.sp = 'b'0 ;

RD     = !(RW & E) ;
ROMcs  =  MREQ #  ROMdisFF ;
RAMoe  =  RD   # !ROMdisFF ;

/* =========================================================
                   SPEED REGISTER
   ========================================================= */

REG_WRITE = SPDsel & !RW ;

/* DEFAULT: slow or normal will come from reset, not here */
S1.d  = (REG_WRITE & D1) # (!REG_WRITE & S1) ;
S0.d  = (REG_WRITE & D0) # (!REG_WRITE & S0) ;

S1.ck = E ;
S0.ck = E ;
S1.ar = RESET ;  /* S1 clears on reset */
S0.ar = RESET ;  /* S0 clears on reset (default slow until you write) */
S1.sp = 'b'0 ;
S0.sp = 'b'0 ;

/* =========================================================
                   CLOCK DIVIDERS
   ========================================================= */

/* All three flip-flops are clocked by CLK4x */

DIV2.d  = !DIV2 ;                   /* toggles every clock -> /2 */
DIV4.d  = DIV4 $ DIV2 ;             /* toggles when DIV2 wraps -> /4 */
DIV8.d  = DIV8 $ (DIV2 & DIV4) ;    /* toggles when DIV4 & DIV2 are 1 -> /8 */

DIV2.ck = CLK4x ;
DIV4.ck = CLK4x ;
DIV8.ck = CLK4x ;

DIV2.ar = RESET ;
DIV4.ar = RESET ;
DIV8.ar = RESET ;

DIV2.sp = 'b'0 ;
DIV4.sp = 'b'0 ;
DIV8.sp = 'b'0 ;

/* =========================================================
                   SPEED MUX (CPU CLOCK)
   ========================================================= */

SPD_TURBO  =  S1 &  S0 ;  /* 16 MHz */
SPD_FAST   =  S1 & !S0 ;  /* 8 MHz */
SPD_NORMAL = !S1 &  S0 ;  /* 4 MHz */
SPD_SLOW   = !S1 & !S0 ;  /* 2 MHz */

CPUclk = (SPD_TURBO  & CLK4x) #
         (SPD_FAST   & DIV2)  #
         (SPD_NORMAL & DIV4)  #
         (SPD_SLOW   & DIV8)  ;

/* =========================================================
                      RGB LED OUTPUTS
   ========================================================= */

LED_R = SPD_TURBO # SPD_FAST ;
LED_G = SPD_NORMAL # SPD_FAST ;
LED_B = SPD_SLOW ;

/* =========================================================
                        HALT LOGIC
   ========================================================= */
/* Detect any change to the speed register (S1,S0) on a write */

CHANGE_S1 = (REG_WRITE &  D1 & !S1) #
            (REG_WRITE & !D1 &  S1) ;

CHANGE_S0 = (REG_WRITE &  D0 & !S0) #
            (REG_WRITE & !D0 &  S0) ;

CHANGE      = CHANGE_S1 # CHANGE_S0 ;
HALT_ACTIVE = CHANGE    & REG_WRITE ;

/* ---------------- EXTENDED STRETCH FOR SPEED CHANGE ------ */
/* Shift a "1" through H0..H3 to keep HALTout asserted       */
/* for several CLK4x cycles after a speed change.            */

PINNODE 28 = H0 ;
PINNODE 29 = H1 ;
PINNODE 30 = H2 ;
PINNODE 34 = H3 ;

H0.d  = HALT_ACTIVE ;
H1.d  = H0 ;
H2.d  = H1 ;
H3.d  = H2 ;

H0.ck = CLK4x ;
H1.ck = CLK4x ;
H2.ck = CLK4x ;
H3.ck = CLK4x ;

H0.ar = RESET ;
H1.ar = RESET ;
H2.ar = RESET ;
H3.ar = RESET ;

H0.sp = 'b'0 ;
H1.sp = 'b'0 ;
H2.sp = 'b'0 ;
H3.sp = 'b'0 ;

/* Stretched speed-change halt:
   - HALT_ACTIVE itself
   - plus 4 extra CLK4x stages via H0..H3
   This gives up to 5 CLK4x cycles of /HALT assertion
   per speed change event.
*/
HALT_SPEED_STRETCHED = HALT_ACTIVE # H0 # H1 # H2 # H3 ;

/* Final HALT request:
   - External halts (HALTin) are level-sensitive.
   - Pause switch is level-sensitive.
   - Speed-change halt is stretched as above.
   Note: internal HALTout=1 -> external pin !HALTout is LOW.
*/
HALTout = HALTin # PAUSEsw # HALT_SPEED_STRETCHED ;

/* =========================================================
                     TRI-STATE READBACK LOGIC
   ========================================================= */

REG_READ = SPDsel & RW ;

D1    = REG_READ & S1 ;
D1.oe = REG_READ ;

D0    = REG_READ & S0 ;
D0.oe = REG_READ ;
